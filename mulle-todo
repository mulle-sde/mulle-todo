#! /usr/bin/env mulle-bash
#! MULLE_BASHFUNCTIONS_VERSION=6.6.3
# shellcheck shell=bash
#
#
#  mulle-todo.sh
#
#  Copyright (c) 2025 Nat! - Mulle kybernetiK
#  All rights reserved.
#
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions are met:
#
#  Redistributions of source code must retain the above copyright notice, this
#  list of conditions and the following disclaimer.
#
#  Redistributions in binary form must reproduce the above copyright notice,
#  this list of conditions and the following disclaimer in the documentation
#  and/or other materials provided with the distribution.
#
#  Neither the name of <ORGANIZATION> nor the names of its contributors
#  may be used to endorse or promote products derived from this software
#  without specific prior written permission.
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
#  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
#  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
#  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
#  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
#  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
#  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#  POSSIBILITY OF SUCH DAMAGE.
#

[ "${TRACE}" = 'YES' -o "${MULLE_TODO_TRACE}" = 'YES' ] && set -x  && : "$0" "$@"

### >> START OF mulle-boot.sh >>
### << END OF mulle-boot.sh <<

#
# Versioning of this script
#
MULLE_EXECUTABLE_VERSION="0.0.0"


### >> START OF mulle-bashfunctions-embed.sh >>
### << END OF mulle-bashfunctions-embed.sh <<

print_flags()
{
   echo "   -f            : force operation"
   echo "   --file <path> : Use custom todo file (default: ~/.mulle/etc/todo/todo.txt)"


   options_technical_flags_usage "         : "
}


usage()
{
   [ $# -ne 0 ] && log_error "$*"


   cat <<EOF >&2
Usage:
   mulle-todo [flags] [command] [args...]

   A simple todo list manager for your shell.

Commands:
   add <text>       : Add a new todo item
   remove <number>  : Remove todo item by number
   remove-all       : Remove all todo items
   up <number>      : Move item up in the list
   down <number>    : Move item down in the list
   list [n]         : Display all (or n) todo items (default)
   show [n]         : Display todos like motd (for shell login)
   scan             : Scan source files for TODO comments (requires .mulle project)
   scan-import      : Scan and import TODO comments into todo list
   install          : Install shell integration into your profile

   When listing with a limit [n], top 3 items stay in order,
   remaining items are randomly selected to keep all todos visible.

Flags:
EOF
   print_flags | LC_ALL=C sort >&2

   exit 1
}


get_todofile()
{
   local tododir
   
   if [ -n "${MULLE_TODO_FILE}" ]
   then
      # Explicit --file flag takes precedence
      RVAL="${MULLE_TODO_FILE}"
   elif [ "${MULLE_TODO_GLOBAL}" = "YES" ]
   then
      # -g/--global flag: use global location
      tododir="${HOME}/.mulle/etc/todo"
      RVAL="${tododir}/todo.txt"
   elif [ -d ".mulle/etc" ]
   then
      # Local .mulle/etc exists: use project-local location
      tododir=".mulle/etc/todo"
      RVAL="${tododir}/todo.txt"
   else
      # Default: global location
      tododir="${HOME}/.mulle/etc/todo"
      RVAL="${tododir}/todo.txt"
   fi
}

calculate_visual_width()
{
   # Locale-independent: operate on hex of full string and step by UTF-8 sequence length
   local text="$1"
   local hex
   hex=$(printf '%s' "${text}" | od -An -tx1 | tr -d ' \n')
   local visual_width=0
   local pos=0
   local hlen=${#hex}
   local b1 b2 b3 codepoint

   while [ ${pos} -lt ${hlen} ]
   do
      b1=$((16#${hex:${pos}:2}))
      if (( b1 < 0x80 )); then
         visual_width=$((visual_width + 1))
         pos=$((pos + 2))
      elif (( b1 >= 0xC0 && b1 <= 0xDF )); then
         # 2-byte
         visual_width=$((visual_width + 1))
         pos=$((pos + 4))
      elif (( b1 >= 0xE0 && b1 <= 0xEF )); then
         # 3-byte
         b2=$((16#${hex:$((pos+2)):2}))
         b3=$((16#${hex:$((pos+4)):2}))
         codepoint=$(( ((b1 & 0x0F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F) ))
         if (( (codepoint >= 0x2300 && codepoint <= 0x24FF) ||
               (codepoint >= 0x2600 && codepoint <= 0x27BF) ||
               (codepoint >= 0x2B00 && codepoint <= 0x2BFF) )); then
            visual_width=$((visual_width + 2))
         else
            visual_width=$((visual_width + 1))
         fi
         pos=$((pos + 6))
      elif (( b1 >= 0xF0 && b1 <= 0xF7 )); then
         # 4-byte (supplementary planes) => width 2
         visual_width=$((visual_width + 2))
         pos=$((pos + 8))
      else
         # Fallback: advance one byte
         visual_width=$((visual_width + 1))
         pos=$((pos + 2))
      fi
   done
   RVAL="${visual_width}"
}

ensure_todofile()
{
   local todofile
   
   get_todofile
   todofile="${RVAL}"
   
   r_mkdir_parent_if_missing "${todofile}"
   
   if [ ! -f "${todofile}" ]
   then
      redirect_exekutor "${todofile}" printf "%s\n" "# Todo List"
   fi
}

read_todos()
{
   local todofile
   
   get_todofile
   todofile="${RVAL}"
   
   if [ ! -f "${todofile}" ]
   then
      RVAL=""
      return
   fi
   
   RVAL="$(grep -v '^#' "${todofile}" 2>/dev/null || true)"
}

write_todos()
{
   local todos="$1"
   local todofile
   
   get_todofile
   todofile="${RVAL}"
   
   ensure_todofile
   
   {
      printf "%s\n" "# Todo List"
      printf "%s\n" "${todos}"
   } > "${todofile}"
}

todo_add()
{
   local text="$*"
   local todofile
   
   [ -z "${text}" ] && fail "No todo text provided"
   
   ensure_todofile
   get_todofile
   todofile="${RVAL}"
   
   redirect_append_exekutor "${todofile}" printf "%s\n" "${text}"
   
   log_info "Added: ${text}"
}

todo_remove()
{
   local number="$1"
   local todos
   local count
   local i
   local line
   
   [ -z "${number}" ] && fail "No item number provided"
   
   read_todos
   todos="${RVAL}"
   
   [ -z "${todos}" ] && fail "Todo list is empty"
   
   count=$(printf "%s\n" "${todos}" | wc -l)
   
   [ "${number}" -lt 1 ] && fail "Item number must be >= 1"
   [ "${number}" -gt "${count}" ] && fail "Item number ${number} out of range (1-${count})"
   
   local todofile
   get_todofile
   todofile="${RVAL}"
   
   {
      printf "%s\n" "# Todo List"
      i=1
      while IFS= read -r line || [ -n "${line}" ]
      do
         if [ "${i}" -ne "${number}" ]
         then
            printf "%s\n" "${line}"
         fi
         i=$((i + 1))
      done <<< "${todos}"
   } > "${todofile}"
   
   log_info "Removed item ${number}"
}

todo_remove_all()
{
   local todofile
   
   get_todofile
   todofile="${RVAL}"
   
   if [ ! -f "${todofile}" ]
   then
      log_info "Todo list is already empty"
      return
   fi
   
   redirect_exekutor "${todofile}" printf "%s\n" "# Todo List"
   log_info "Removed all todo items"
}

todo_move_up()
{
   local number="$1"
   local todos
   local count
   local i
   local line
   local prev_line
   
   [ -z "${number}" ] && fail "No item number provided"
   
   read_todos
   todos="${RVAL}"
   
   [ -z "${todos}" ] && fail "Todo list is empty"
   
   count=$(printf "%s\n" "${todos}" | wc -l)
   
   [ "${number}" -lt 2 ] && fail "Item ${number} cannot be moved up"
   [ "${number}" -gt "${count}" ] && fail "Item number ${number} out of range (1-${count})"
   
   local todofile
   get_todofile
   todofile="${RVAL}"
   
   {
      printf "%s\n" "# Todo List"
      i=1
      prev_line=""
      while IFS= read -r line || [ -n "${line}" ]
      do
         if [ "${i}" -eq $((number - 1)) ]
         then
            prev_line="${line}"
         elif [ "${i}" -eq "${number}" ]
         then
            printf "%s\n" "${line}"
            printf "%s\n" "${prev_line}"
         else
            printf "%s\n" "${line}"
         fi
         i=$((i + 1))
      done <<< "${todos}"
   } > "${todofile}"
   
   log_info "Moved item ${number} up"
}

todo_move_down()
{
   local number="$1"
   local todos
   local count
   local i
   local line
   local next_line
   local skip_next
   
   [ -z "${number}" ] && fail "No item number provided"
   
   read_todos
   todos="${RVAL}"
   
   [ -z "${todos}" ] && fail "Todo list is empty"
   
   count=$(printf "%s\n" "${todos}" | wc -l)
   
   [ "${number}" -lt 1 ] && fail "Item number must be >= 1"
   [ "${number}" -ge "${count}" ] && fail "Item ${number} cannot be moved down"
   
   local todofile
   local -a lines_arr
   get_todofile
   todofile="${RVAL}"
   
   IFS=$'\n' read -d '' -ra lines_arr <<< "${todos}" || true
   
   {
      printf "%s\n" "# Todo List"
      for ((i=0; i<${#lines_arr[@]}; i++))
      do
         if [ $((i + 1)) -eq "${number}" ]
         then
            printf "%s\n" "${lines_arr[$((i + 1))]}"
            printf "%s\n" "${lines_arr[${i}]}"
            i=$((i + 1))
         else
            printf "%s\n" "${lines_arr[${i}]}"
         fi
      done
   } > "${todofile}"
   
   log_info "Moved item ${number} down"
}

todo_list()
{
   local todos
   local i
   local line
   local limit="${1}"
   local count
   local -a all_lines
   local -a display_lines
   local todofile
   
   get_todofile
   todofile="${RVAL}"
   
   read_todos
   todos="${RVAL}"
   
   if [ -z "${todos}" ]
   then
      if [ -d ".mulle/etc" ] && [ "${MULLE_TODO_GLOBAL}" != "YES" ]
      then
         log_info "No todos in this project yet. Add one with: mulle-todo add <text>"
      else
         log_info "No todos yet. Add one with: mulle-todo add <text>"
      fi
      return
   fi
   
   IFS=$'\n' read -d '' -ra all_lines <<< "${todos}" || true
   count=${#all_lines[@]}
   
   if [ -n "${limit}" ] && [ "${limit}" -lt "${count}" ]
   then
      # Handle small limits
      if [ "${limit}" -le 3 ]
      then
         # Just show the first N items
         for ((i=0; i<limit && i<count; i++))
         do
            printf "%3d. %s\n" "$((i + 1))" "${all_lines[${i}]}"
         done
         printf "\n... showing %d of %d items\n" "${limit}" "${count}"
         return
      fi
      
      # Keep top 3, randomize the rest
      local -a top_three
      local -a rest
      local -a shuffled
      
      # Get top 3
      for ((i=0; i<3 && i<count; i++))
      do
         top_three+=("${all_lines[${i}]}")
      done
      
      # Get remaining items
      for ((i=3; i<count; i++))
      do
         rest+=("${all_lines[${i}]}")
      done
      
      # Shuffle remaining items
      if [ ${#rest[@]} -gt 0 ]
      then
         local oldifs="${IFS}"
         IFS=$'\n'
         shuffled=($(printf "%s\n" "${rest[@]}" | shuf))
         IFS="${oldifs}"
      fi
      
      # Build display list
      display_lines=("${top_three[@]}")
      
      local remaining=$((limit - 3))
      if [ "${remaining}" -gt 0 ] && [ ${#shuffled[@]} -gt 0 ]
      then
         for ((i=0; i<remaining && i<${#shuffled[@]}; i++))
         do
            display_lines+=("${shuffled[${i}]}")
         done
      fi
      
      # Display
      for ((i=0; i<${#display_lines[@]}; i++))
      do
         printf "%3d. %s\n" "$((i + 1))" "${display_lines[${i}]}"
      done
      
      if [ "${limit}" -lt "${count}" ]
      then
         printf "\n... showing %d of %d items (top 3 + random %d)\n" "${limit}" "${count}" "$((limit - 3))"
      fi
   else
      # Display all
      i=1
      for line in "${all_lines[@]}"
      do
         printf "%3d. %s\n" "${i}" "${line}"
         i=$((i + 1))
      done
   fi
}

todo_show()
{
   local todos
   local i
   local line
   local limit="${1}"
   local count
   local -a all_lines
   local -a display_lines
   local max_width=0
   local term_width
   local box_width
   local todofile
   
   get_todofile
   todofile="${RVAL}"
   
   read_todos
   todos="${RVAL}"
   
   if [ -z "${todos}" ]
   then
      if [ -d ".mulle/etc" ] && [ "${MULLE_TODO_GLOBAL}" != "YES" ]
      then
         log_info "No todos in this project yet. Add one with: mulle-todo add <text>"
      else
         log_info "No todos yet. Add one with: mulle-todo add <text>"
      fi
      return
   fi
   
   # Colors
   local CYAN='\033[1;36m'
   local GREEN='\033[1;32m'
   local YELLOW='\033[1;33m'
   local BLUE='\033[1;34m'
   local RESET='\033[0m'
   
   IFS=$'\n' read -d '' -ra all_lines <<< "${todos}" || true
   count=${#all_lines[@]}
   
   # Determine which items to display
   if [ -n "${limit}" ] && [ "${limit}" -lt "${count}" ]
   then
      # Handle small limits
      if [ "${limit}" -le 3 ]
      then
         for ((i=0; i<limit && i<count; i++))
         do
            display_lines+=("${all_lines[${i}]}")
         done
      else
         # Keep top 3, randomize the rest
         local -a top_three
         local -a rest
         local -a shuffled
         
         for ((i=0; i<3 && i<count; i++))
         do
            top_three+=("${all_lines[${i}]}")
         done
         
         for ((i=3; i<count; i++))
         do
            rest+=("${all_lines[${i}]}")
         done
         
         if [ ${#rest[@]} -gt 0 ]
         then
            local oldifs="${IFS}"
            IFS=$'\n'
            shuffled=($(printf "%s\n" "${rest[@]}" | shuf))
            IFS="${oldifs}"
         fi
         
         display_lines=("${top_three[@]}")
         
         local remaining=$((limit - 3))
         if [ "${remaining}" -gt 0 ] && [ ${#shuffled[@]} -gt 0 ]
         then
            for ((i=0; i<remaining && i<${#shuffled[@]}; i++))
            do
               display_lines+=("${shuffled[${i}]}")
            done
         fi
      fi
   else
      display_lines=("${all_lines[@]}")
   fi
   
   # Calculate max content width considering number width and emoji
   # Number width: "‚ñ∏ NNN. " where NNN can be 1-3 digits
   local num_items=${#display_lines[@]}
   local num_width=${#num_items}  # digits in highest number
   local prefix_width=$((num_width + 4))  # "‚ñ∏ N. " minimum
   
   for line in "${display_lines[@]}"
   do
      calculate_visual_width "${line}"
      local visual_len="${RVAL}"
      local total_width=$((prefix_width + visual_len))
      
      [ ${total_width} -gt ${max_width} ] && max_width=${total_width}
   done
   
   log_setting "data line content width (prefix+text): ${max_width}"
   
   # Set box width
   term_width=$(tput cols 2>/dev/null || echo 80)
   box_width=$((max_width + 2))  # box_width = longest content + 2 spaces
   [ ${box_width} -lt 40 ] && box_width=40
   [ ${box_width} -gt $((term_width - 4)) ] && box_width=$((term_width - 4))
   
   log_setting "box_width (‚îÅ characters): ${box_width}"
   
   local content_width=${max_width}  # Longest prefix+text (no outer spaces)
   
   log_setting "content_width (available for data): ${content_width}"
   
   # Draw box with heavy style
   printf "%b" "${CYAN}‚îè"
   printf '‚îÅ%.0s' $(seq 1 ${box_width})
   printf "%b\n" "‚îì${RESET}"
   
   # Title - "üìã TODO" with background pattern
   local title="üìã TODO"
   calculate_visual_width "${title}"
   local title_visual_width="${RVAL}"
   
   log_setting "title visual width (just emoji+text): ${title_visual_width}"
   
   # Total needed: space + title + space  
   local total_title_width=$((1 + title_visual_width + 1))
   
   log_setting "title total width (with spaces): ${total_title_width}"
   
   # Remaining space for background
   local remaining=$((box_width - total_title_width))
   local left_bg=$((remaining / 2))
   local right_bg=$((remaining - left_bg))
   
   log_setting "title background: left=${left_bg}, right=${right_bg}"
   printf "%b" "${CYAN}‚îÉ"
   # Left background (keep color on)
   printf "‚ñë%.0s" $(seq 1 ${left_bg})
   printf "%b" "${RESET} ${YELLOW}${title}${RESET} ${CYAN}"
   # Right background
   printf "‚ñë%.0s" $(seq 1 ${right_bg})
   printf "%b\n" "‚îÉ${RESET}"
   
   # Separator
   printf "%b" "${CYAN}‚î£"
   printf '‚îÅ%.0s' $(seq 1 ${box_width})
   printf "%b\n" "‚î´${RESET}"
   
   # Items
   for ((i=0; i<${#display_lines[@]}; i++))
   do
      local item_num=$((i + 1))
      local item_text="${display_lines[${i}]}"
      
      # Calculate actual visual width needed for this item
      local num_digits=${#item_num}
      calculate_visual_width "${item_text}"
      local text_visual_width="${RVAL}"
      local item_prefix_width=$((num_digits + 4))  # "‚ñ∏ N. "
      local needed_width=$((item_prefix_width + text_visual_width))
      
      # Truncate if too long
      local max_text_width=$((content_width - 2 - item_prefix_width))
      if [ ${text_visual_width} -gt ${max_text_width} ]; then
         # Rough truncation
         local keep_chars=$((max_text_width - 4))
         item_text="${item_text:0:${keep_chars}}..."
         calculate_visual_width "${item_text}"
         text_visual_width="${RVAL}"
      fi
      
      local padding_right=$((max_width - (item_prefix_width + text_visual_width)))
      [ ${padding_right} -lt 0 ] && padding_right=0
      
      printf "%b" "${CYAN}‚îÉ${RESET} "
      printf "%b" "${GREEN}‚ñ∏${RESET} ${BLUE}${item_num}.${RESET} ${item_text}"
      printf ' %.0s' $(seq 1 ${padding_right})
      printf "%b\n" "${CYAN} ‚îÉ${RESET}"
   done
   
   # Show truncation info if applicable
   if [ -n "${limit}" ] && [ "${limit}" -lt "${count}" ]
   then
      printf "%b" "${CYAN}‚î£"
      printf '‚îÅ%.0s' $(seq 1 ${box_width})
      printf "%b\n" "‚î´${RESET}"
      
      local info_text
      if [ "${limit}" -le 3 ]; then
         info_text="Showing ${limit} of ${count} items"
      else
         local random_count=${#shuffled[@]}
         [ ${random_count} -gt $((limit - 3)) ] && random_count=$((limit - 3))
         info_text="Showing ${limit} of ${count} (top 3 + ${random_count} random)"
      fi
      
      # "‚ú® " is 3 visual width (emoji=2, space=1)
      local info_visual_len=$((${#info_text} + 3))
      local info_padding=$(( (box_width - info_visual_len) / 2 ))
      
      printf "%b" "${CYAN}‚îÉ${RESET}"
      printf ' %.0s' $(seq 1 ${info_padding})
      printf "%b" "${YELLOW}‚ú® ${info_text}${RESET}"
      printf ' %.0s' $(seq 1 $((box_width - info_visual_len - info_padding)))
      printf "%b\n" "${CYAN}‚îÉ${RESET}"
   fi
   
   # Bottom border
   printf "%b" "${CYAN}‚îó"
   printf '‚îÅ%.0s' $(seq 1 ${box_width})
   printf "%b\n" "‚îõ${RESET}"
}

todo_scan()
{
   local import_mode="${1}"  # "import" or empty for display
   local file
   local -a files
   local line
   local in_todo=0
   local todo_text=""
   local todo_file=""
   local todo_line=""
   local count=0
   local -a scanned_todos

   # Only works in mulle projects
   if [ ! -d ".mulle" ]
   then
      fail "TODO scanning requires a .mulle directory (mulle project)"
   fi

   # Check if mulle-sde is available
   if command -v mulle-sde >/dev/null 2>&1
   then
      log_info "Using mulle-sde to get file list..."
      IFS=$'\n' read -d '' -ra files < <(mulle-sde files --raw-files 2>/dev/null) || true
   else
      log_info "Using find to get file list (mulle-sde not found)..."
      IFS=$'\n' read -d '' -ra files < <(find . -type f \( -name "*.c" -o -name "*.h" -o -name "*.m" -o -name "*.sh" -o -name "*.py" -o -name "*.js" -o -name "*.java" \) ! -path "./.mulle/*" 2>/dev/null) || true
   fi

   if [ ${#files[@]} -eq 0 ]
   then
      log_warning "No files found to scan"
      return
   fi

   # If in import mode, first collect all scanned TODOs
   if [ "${import_mode}" = "import" ]
   then
      scanned_todos=()
   fi

   # Process each file
   for file in "${files[@]}"
   do
      [ ! -f "${file}" ] && continue

      in_todo=0
      todo_text=""
      todo_file="${file}"
      todo_line=""

      while IFS= read -r line
      do
         # Check for TODO markers
         if [[ "${line}" =~ (//|#|/\*)[[:space:]]*TODO:?[[:space:]]*(.*) ]]
         then
            # Start of a TODO
            in_todo=1
            todo_text="${BASH_REMATCH[2]}"
            todo_line="${line}"

            # Check if it's a single line TODO
            if [[ "${line}" =~ ^[[:space:]]*(//|#)[[:space:]]*TODO ]]; then
               # Single line comment style - continue reading consecutive comments
               :
            elif [[ "${line}" =~ /\*.*\*/ ]]; then
               # Single line /* TODO */ style
               if [ "${import_mode}" = "import" ]
               then
                  scanned_todos+=("üìù ${todo_file}: ${todo_text}")
               else
                  printf "  üìù %s: %s\n" "${todo_file}" "${todo_text}"
               fi
               count=$((count + 1))
               in_todo=0
               todo_text=""
            fi
         elif [ ${in_todo} -eq 1 ]
         then
            # Check if line continues the comment
            if [[ "${line}" =~ ^[[:space:]]*(//|#)[[:space:]]+(.*) ]]; then
               # Continuation of single-line comment style
               local continuation="${BASH_REMATCH[2]}"
               if [ -n "${continuation}" ]; then
                  todo_text="${todo_text} ${continuation}"
               fi
            elif [[ "${line}" =~ ^[[:space:]]*\*[[:space:]]+(.*) ]]; then
               # Continuation of /* */ style comment
               local continuation="${BASH_REMATCH[1]}"
               if [ -n "${continuation}" ]; then
                  todo_text="${todo_text} ${continuation}"
               fi
            elif [[ "${line}" =~ \*/ ]]; then
               # End of /* */ style comment
               if [ "${import_mode}" = "import" ]
               then
                  scanned_todos+=("üìù ${todo_file}: ${todo_text}")
               else
                  printf "  üìù %s: %s\n" "${todo_file}" "${todo_text}"
               fi
               count=$((count + 1))
               in_todo=0
               todo_text=""
            else
               # Not a comment continuation - output current TODO
               if [ -n "${todo_text}" ]; then
                  if [ "${import_mode}" = "import" ]
                  then
                     scanned_todos+=("üìù ${todo_file}: ${todo_text}")
                  else
                     printf "  üìù %s: %s\n" "${todo_file}" "${todo_text}"
                  fi
                  count=$((count + 1))
               fi
               in_todo=0
               todo_text=""
            fi
         fi
      done < "${file}"

      # Output any remaining TODO
      if [ ${in_todo} -eq 1 ] && [ -n "${todo_text}" ]
      then
         if [ "${import_mode}" = "import" ]
         then
            scanned_todos+=("üìù ${todo_file}: ${todo_text}")
         else
            printf "  üìù %s: %s\n" "${todo_file}" "${todo_text}"
         fi
         count=$((count + 1))
      fi
   done

   if [ ${count} -eq 0 ]
   then
      log_info "No TODO comments found in source files"
      if [ "${import_mode}" = "import" ]
      then
         # Still need to remove old scanned todos
         remove_scanned_todos
      fi
      return
   else
      log_info "Found ${count} TODO comment(s)"
   fi
   
   # Import mode: replace all scanned todos
   if [ "${import_mode}" = "import" ]
   then
      log_verbose "Removing old scanned TODOs..."
      remove_scanned_todos
      
      log_verbose "Adding ${#scanned_todos[@]} new scanned TODOs..."
      local todofile
      ensure_todofile
      get_todofile
      todofile="${RVAL}"
      
      for todo_text in "${scanned_todos[@]}"
      do
         r_add_unique_line "${todofile}" "${todo_text}"
         redirect_append_exekutor "${todofile}" printf "%s\n" "${RVAL}"
      done
      
      log_info "Imported ${#scanned_todos[@]} TODO(s) from source files"
   fi
}

remove_scanned_todos()
{
   local todofile
   local todos
   local line
   local -a filtered_todos
   
   get_todofile
   todofile="${RVAL}"
   
   [ ! -f "${todofile}" ] && return
   
   read_todos
   todos="${RVAL}"
   
   [ -z "${todos}" ] && return
   
   # Keep only todos that don't start with üìù
   filtered_todos=()
   while IFS= read -r line
   do
      # Skip lines that start with üìù (auto-generated from scan)
      if [[ ! "${line}" =~ ^üìù[[:space:]] ]]
      then
         filtered_todos+=("${line}")
      fi
   done <<< "${todos}"
   
   # Write back the filtered list
   {
      printf "%s\n" "# Todo List"
      for line in "${filtered_todos[@]}"
      do
         printf "%s\n" "${line}"
      done
   } > "${todofile}"
}

install_shell_integration()
{
   local shell_rc
   local integration_code
   local uname

   # Detect platform
   uname="${MULLE_UNAME:-$(uname)}"

   case "${uname}" in
      darwin|Darwin)
         # macOS - zsh is default since Catalina
         if [ -n "${ZSH_VERSION}" ] || [ "${SHELL}" = "/bin/zsh" ] || [ "${SHELL}" = "/usr/bin/zsh" ]
         then
            shell_rc="${HOME}/.zshrc"
         else
            shell_rc="${HOME}/.bash_profile"
         fi
      ;;

      linux|Linux)
         # Linux - check what shell is being used
         if [ -n "${ZSH_VERSION}" ] || [ "${SHELL}" = "/bin/zsh" ] || [ "${SHELL}" = "/usr/bin/zsh" ]
         then
            shell_rc="${HOME}/.zshrc"
         else
            shell_rc="${HOME}/.bashrc"
         fi
      ;;

      *)
         # Default to .profile for unknown platforms
         shell_rc="${HOME}/.profile"
      ;;
   esac

   # Check if already installed
   if [ -f "${shell_rc}" ] && grep -q "mulle-todo show" "${shell_rc}" 2>/dev/null
   then
      log_info "Shell integration already installed in ${shell_rc}"
      return 0
   fi

   # Integration code (without aliases)
   integration_code='
# mulle-todo - Display todos on shell login
if command -v mulle-todo >/dev/null 2>&1; then
    mulle-todo show 8 2>/dev/null
fi
'

   # Backup existing rc file
   if [ -f "${shell_rc}" ]
   then
      log_verbose "Backing up ${shell_rc} to ${shell_rc}.bak"
      cp "${shell_rc}" "${shell_rc}.bak"
   fi

   # Append integration code
   log_info "Installing shell integration into ${shell_rc}"
   printf "%s\n" "${integration_code}" >> "${shell_rc}"

   log_info "‚úÖ Shell integration installed successfully!"
   log_info "Open a new shell or run: source ${shell_rc}"
}

main()
{
   local OPTION_VALUE
   local cmd

   while [ $# -ne 0 ]
   do
      if options_technical_flags "$1"
      then
         shift
         continue
      fi

      case "$1" in
         -f|--force)
            MULLE_FLAG_MAGNUM_FORCE='YES'
         ;;

         -g|--global)
            MULLE_TODO_GLOBAL='YES'
         ;;

         --file)
            [ $# -eq 1 ] && usage "missing argument to $1"
            shift

            MULLE_TODO_FILE="$1"
         ;;

         --debug-string)
            [ $# -eq 1 ] && usage "missing argument to $1"
            shift

            # Debug: calculate visual width and show hex dump
            calculate_visual_width "$1"
            printf "Visual width: %d\n" "${RVAL}"
            printf "%s\n" "$1" | hexdump -C
            exit 0
         ;;

         -h*|--help|help)
            usage
         ;;

         --version)
            printf "%s\n" "${MULLE_EXECUTABLE_VERSION}"
            exit 0
         ;;

         -*)
            usage "Unknown flag \"$1\""
         ;;

         *)
            break
         ;;
      esac

      shift
   done

   options_setup_trace "${MULLE_TRACE}" && set -x

   cmd="${1:-show}"
   shift || true

   case "${cmd}" in
      add)
         todo_add "$@"
      ;;
      
      remove|rm|del)
         todo_remove "$@"
      ;;
      
      remove-all|clear)
         todo_remove_all
      ;;
      
      up)
         todo_move_up "$@"
      ;;
      
      down)
         todo_move_down "$@"
      ;;
      
      list|ls)
         todo_list "$@"
      ;;
      
      show)
         todo_show "$@"
      ;;
      
      scan)
         todo_scan
      ;;

      scan-import)
         todo_scan "import"
      ;;

      install|install-shell-integration)
         install_shell_integration
      ;;

      *)
         fail "Unknown command: ${cmd}"
      ;;
   esac
}

main "$@"
